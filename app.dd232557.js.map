{"version":3,"sources":["webpack:///./src/map.js","webpack:///./src/index.js"],"names":["INITIAL_COORDS","roleColors","buildFeature","feature","featureObject","variable","hasOwnProperty","properties","trim","geometry","coordinates","push","parseFloat","parseDMS","input","parts","split","degrees","minutes","seconds","direction","dd","parseInt","convertDMSToDD","document","querySelector","innerHTML","window","addEventListener","Papa","download","header","complete","results","data","geoJSON","featureCollection","i","length","replace","lon","lat","match","isNaN","built","e","console","log","buildGeoJSON","features","map","L","center","zoom","scrollWheelZoom","maxZoom","attribution","id","addTo","pointToLayer","latlng","radius","fillColor","color","weight","opacity","fillOpacity","onEachFeature","layer","prop","bindPopup","loadMap","setTimeout","getElementById","style","display","colors","colorsHTML","join","Map"],"mappings":"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","file":"app.dd232557.js","sourcesContent":["import * as Papa from 'papaparse'\nimport * as L from 'leaflet'\n\nconst publicSpreadsheetUrl = 'https://docs.google.com/spreadsheets/d/19ss6dmhb2B9qFWZQVODeYFJzMBCvyd5fPy8bjkA3CB8/pub?gid=1619676924&output=csv'\nconst MAPBOX_LINK = 'https://api.mapbox.com/styles/v1/bernardosp/ck3r9ne5k21bj1dpdgl67vzyu/tiles/256/{z}/{x}/{y}@2x?access_token=pk.eyJ1IjoiYmVybmFyZG9zcCIsImEiOiJjamkyMmhqdjAwZ284M2txcHpqYjUwam91In0.RiploEl5Mm6bjXhPZbN6XQ'\nconst LAT_COL = 'LAT'\nconst LON_COL = 'LON'\nconst INITIAL_COORDS = [37.76496739271615, -122.39985495803376]\nconst INITIAL_ZOOM = 8\n\nconst roleColors = {\n  'Architectural / Consulting Firm': '#ff7f0e',\n  'Deconstruction': '#2ca02c',\n  'Government / Public Agency': '#aec7e8',\n  'Reuse': '#9467bd',\n  'Waste Management & Recycling': '#bcbd22',\n}\n\nexport {\n  init,\n  roleColors,\n  mapLegend,\n}\n\nfunction init() {\n  Papa.parse(publicSpreadsheetUrl, {\n  download: true,\n  header: true,\n  complete: function(results) {\n      const data = results.data\n      const geoJSON = buildGeoJSON(data)\n      console.log(data)\n      console.log(geoJSON)\n      console.log(data.length, 'rows received')\n      console.log(geoJSON.features.length, 'rows parsed')\n      loadMap(geoJSON)\n      setTimeout(function(){\n        document.getElementById('spinner').style.display = 'none'\n      }, 350)\n    }\n  })\n}\n\nfunction buildFeature(feature) {\n  let featureObject = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\n      \"type\": \"Point\",\n      \"coordinates\": []\n    }\n  }\n  for (let variable in feature) {\n    if (feature.hasOwnProperty(variable)) {\n      featureObject.properties[variable.trim()] = feature[variable].trim()\n    }\n  }\n  featureObject.geometry.coordinates.push(parseFloat(feature[LON_COL]))\n  featureObject.geometry.coordinates.push(parseFloat(feature[LAT_COL]))\n  return featureObject\n}\n\nfunction buildGeoJSON(data) {\n  let featureCollection = {\n    \"type\": \"FeatureCollection\",\n    \"features\": []\n  }\n  for (var i = 0; i < data.length; i++) {\n    let feature = data[i]\n    feature[LON_COL] = feature[LON_COL].replace(',', '.')\n    feature[LAT_COL] = feature[LAT_COL].replace(',', '.')\n    let lon = feature[LON_COL]\n    let lat = feature[LAT_COL]\n    if (lon.match(/[a-z]/i) && lat.match(/[a-z]/i)) {\n      feature[LON_COL] = parseDMS(feature[LON_COL])\n      feature[LAT_COL] = parseDMS(feature[LAT_COL])\n    }\n    try {\n      if (isNaN(parseFloat(lon)) == false && isNaN(parseFloat(lat)) == false) {\n        let built = buildFeature(feature)\n        featureCollection['features'].push(built)\n      }\n    } catch (e) {\n        console.log('error parsing row', i, e)\n    }\n  }\n  return featureCollection\n}\n\nfunction loadMap(geoJSON) {\n  const map = L.map('map', {\n    center: INITIAL_COORDS,\n    zoom: INITIAL_ZOOM,\n    scrollWheelZoom: false\n  })\n\n  L.tileLayer(MAPBOX_LINK, {\n    maxZoom: 18,\n    attribution: 'Map data &copy <a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors, ' +\n      '<a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA</a>, ' +\n      'Imagery Â© <a href=\"https://www.mapbox.com/\">Mapbox</a>',\n    id: 'mapbox.light'\n  }).addTo(map)\n\n  function popup(feature, layer) {\n    let prop = feature.properties\n\n    layer.bindPopup(`\n      <div class=\"popup\">\n        <h2>${prop['ENTITY']}</h2>\n        ${prop['LOCATION NAME'] ? `<h4>${prop['LOCATION NAME']}</h4>` : ''}\n        <hr/>\n        <table class=\"table\">\n          <tbody>\n            <tr><td><strong>Role(s)</strong></td><td>${prop['ROLE(S)']}</td></tr>\n            <tr><td><strong>Address</strong></td><td>${prop['FULL ADDRESS']}</td></tr>\n            <tr><td><strong>Contact</strong></td><td>${prop['CONTACT']}</td></tr>\n            <tr><td><strong>Email</strong></td><td>${prop['EMAIL']}</td></tr>\n            <tr><td><strong>Phone</strong></td><td>${prop['PHONE']}</td></tr>\n            <tr><td><strong>Website</strong></td><td><a href=\"${prop['WEBSITE']}\" target=\"_blank\">${prop['WEBSITE']}</a></td></tr>\n          </tbody>\n        </table>\n      </div>\n      `)\n  }\n\n  const pointsLayers = L.geoJSON(geoJSON, {\n    pointToLayer: function(feature, latlng) {\n      console.log(feature);\n      return L.circleMarker(latlng, {\n        radius: 9,\n        fillColor: roleColors[feature.properties['GENERAL ROLE']],\n        color: \"#fff\",\n        weight: 1,\n        opacity: 1,\n        fillOpacity: 0.9,\n      })\n    },\n    onEachFeature: popup\n  }).addTo(map)\n\n}\n\n// https://stackoverflow.com/questions/1140189/converting-latitude-and-longitude-to-decimal-values\nfunction parseDMS(input) {\n    let parts = input.split(/[^\\d\\w\\.]+/)\n    return convertDMSToDD(parts[0], parts[1], parts[2], parts[3])\n}\n\nfunction convertDMSToDD(degrees, minutes, seconds, direction) {\n    let dd = parseInt(degrees) + parseInt(minutes)/60 + parseInt(seconds)/(60*60)\n\n    if (direction == \"S\" || direction == \"W\") {\n        dd = dd * -1\n    }\n    return dd\n}\n\nfunction mapLegend(colors) {\n  const colorsHTML = []\n  for (let variable in colors) {\n    if (colors.hasOwnProperty(variable)) {\n      colorsHTML.push(`\n        <div class=\"map-legend-row flex\">\n          <div class=\"map-legend-color\" style=\"background: ${colors[variable]}\"></div>\n          <span>${variable}</span>\n        </div>\n      `)\n    }\n  }\n  return `<div class=\"map-legend flex flex-column\">${colorsHTML.join('\\n')}</div>`\n}\n","import * as Map from './map.js'\nimport style from './style/main.scss'\n\nconst app = document.querySelector('#app')\n\napp.innerHTML = `\n<div id=\"spinner\">\n  <div class=\"spinner-grow text-secondary\" role=\"status\">\n    <span class=\"sr-only\">Loading...</span>\n  </div>\n</div>\n<div id='map'></div>\n<div id='mapLegend'></div>\n`\n\nwindow.addEventListener('DOMContentLoaded', Map.init)\n\nconst mapLegend = document.querySelector('#mapLegend')\nmapLegend.innerHTML = Map.mapLegend(Map.roleColors)\n"],"sourceRoot":""}